"""
VenomVerse - Molecular Visualization Module
Generates 3D molecular structures for synthetic proteins
"""

import random
import string
from typing import Dict, List, Tuple

class MolecularVisualizer:
    def __init__(self):
        # Amino acid properties for structure generation
        self.amino_acids = {
            'A': {'name': 'Alanine', 'type': 'nonpolar', 'size': 'small'},
            'R': {'name': 'Arginine', 'type': 'positive', 'size': 'large'},
            'N': {'name': 'Asparagine', 'type': 'polar', 'size': 'medium'},
            'D': {'name': 'Aspartic acid', 'type': 'negative', 'size': 'medium'},
            'C': {'name': 'Cysteine', 'type': 'polar', 'size': 'small'},
            'E': {'name': 'Glutamic acid', 'type': 'negative', 'size': 'medium'},
            'Q': {'name': 'Glutamine', 'type': 'polar', 'size': 'medium'},
            'G': {'name': 'Glycine', 'type': 'nonpolar', 'size': 'small'},
            'H': {'name': 'Histidine', 'type': 'positive', 'size': 'medium'},
            'I': {'name': 'Isoleucine', 'type': 'nonpolar', 'size': 'medium'},
            'L': {'name': 'Leucine', 'type': 'nonpolar', 'size': 'medium'},
            'K': {'name': 'Lysine', 'type': 'positive', 'size': 'large'},
            'M': {'name': 'Methionine', 'type': 'nonpolar', 'size': 'medium'},
            'F': {'name': 'Phenylalanine', 'type': 'nonpolar', 'size': 'large'},
            'P': {'name': 'Proline', 'type': 'nonpolar', 'size': 'small'},
            'S': {'name': 'Serine', 'type': 'polar', 'size': 'small'},
            'T': {'name': 'Threonine', 'type': 'polar', 'size': 'small'},
            'W': {'name': 'Tryptophan', 'type': 'nonpolar', 'size': 'large'},
            'Y': {'name': 'Tyrosine', 'type': 'polar', 'size': 'large'},
            'V': {'name': 'Valine', 'type': 'nonpolar', 'size': 'medium'}
        }
        
        # Secondary structure patterns
        self.secondary_structures = {
            'alpha_helix': {'pattern': 'HHHHHHHHH', 'stability': 0.8},
            'beta_sheet': {'pattern': 'EEEEEEEEE', 'stability': 0.7},
            'turn': {'pattern': 'TTT', 'stability': 0.5},
            'loop': {'pattern': 'LLL', 'stability': 0.3}
        }
    
    def generate_protein_sequence(self, length: int, protein_type: str = "therapeutic") -> str:
        """Generate a realistic protein sequence based on type and length"""
        
        # Amino acid frequencies for different protein types
        frequencies = {
            "therapeutic": {
                'A': 0.08, 'R': 0.06, 'N': 0.04, 'D': 0.05, 'C': 0.03,
                'E': 0.06, 'Q': 0.04, 'G': 0.07, 'H': 0.02, 'I': 0.05,
                'L': 0.09, 'K': 0.06, 'M': 0.02, 'F': 0.04, 'P': 0.05,
                'S': 0.07, 'T': 0.05, 'W': 0.01, 'Y': 0.03, 'V': 0.06
            },
            "toxin": {
                'C': 0.12, 'K': 0.08, 'R': 0.08, 'Y': 0.06, 'W': 0.04,
                'F': 0.06, 'L': 0.08, 'I': 0.05, 'V': 0.06, 'A': 0.07,
                'G': 0.06, 'P': 0.06, 'S': 0.06, 'T': 0.05, 'N': 0.04,
                'Q': 0.04, 'D': 0.04, 'E': 0.05, 'H': 0.03, 'M': 0.02
            }
        }
        
        freq = frequencies.get(protein_type, frequencies["therapeutic"])
        amino_acids = list(freq.keys())
        weights = list(freq.values())
        
        sequence = ''.join(random.choices(amino_acids, weights=weights, k=length))
        return sequence
    
    def generate_pdb_structure(self, sequence: str, protein_name: str) -> str:
        """Generate a simplified PDB structure for visualization"""
        
        pdb_lines = []
        
        # Header
        pdb_lines.append(f"HEADER    SYNTHETIC PROTEIN                       {protein_name}")
        pdb_lines.append(f"TITLE     {protein_name} - VENOMVERSE GENERATED STRUCTURE")
        pdb_lines.append("REMARK   1 GENERATED BY VENOMVERSE AI PLATFORM")
        pdb_lines.append("REMARK   2 THIS IS A SIMPLIFIED STRUCTURE FOR VISUALIZATION")
        
        # Generate atomic coordinates (simplified alpha-carbon trace)
        atom_id = 1
        x, y, z = 0.0, 0.0, 0.0
        
        for i, aa in enumerate(sequence):
            residue_num = i + 1
            
            # Simple helix-like coordinates
            angle = i * 100 * 3.14159 / 180  # 100 degrees per residue
            radius = 2.3  # Typical alpha helix radius
            
            x = radius * random.uniform(0.8, 1.2) * (1 + 0.1 * random.random())
            y = radius * random.uniform(0.8, 1.2) * (1 + 0.1 * random.random())
            z = i * 1.5 + random.uniform(-0.3, 0.3)  # 1.5 Ã… rise per residue
            
            # Add some random variation for realistic structure
            x += random.uniform(-0.5, 0.5)
            y += random.uniform(-0.5, 0.5)
            
            # CA atom (alpha carbon)
            pdb_line = f"ATOM  {atom_id:5d}  CA  {aa} A{residue_num:4d}    {x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00           C"
            pdb_lines.append(pdb_line)
            atom_id += 1
            
            # Add CB atom for non-glycine residues
            if aa != 'G':
                cb_x = x + random.uniform(-1.5, 1.5)
                cb_y = y + random.uniform(-1.5, 1.5)
                cb_z = z + random.uniform(-0.5, 0.5)
                
                pdb_line = f"ATOM  {atom_id:5d}  CB  {aa} A{residue_num:4d}    {cb_x:8.3f}{cb_y:8.3f}{cb_z:8.3f}  1.00 20.00           C"
                pdb_lines.append(pdb_line)
                atom_id += 1
        
        pdb_lines.append("END")
        
        return '\n'.join(pdb_lines)
    
    def generate_structure_analysis(self, sequence: str) -> Dict:
        """Analyze protein structure properties"""
        
        # Count amino acid types
        aa_counts = {aa_type: 0 for aa_type in ['nonpolar', 'polar', 'positive', 'negative']}
        size_counts = {'small': 0, 'medium': 0, 'large': 0}
        
        for aa in sequence:
            if aa in self.amino_acids:
                aa_counts[self.amino_acids[aa]['type']] += 1
                size_counts[self.amino_acids[aa]['size']] += 1
        
        total_aa = len(sequence)
        
        # Calculate properties
        hydrophobicity = (aa_counts['nonpolar'] / total_aa) * 100
        charge_ratio = (aa_counts['positive'] + aa_counts['negative']) / total_aa * 100
        
        # Predict secondary structure content (simplified)
        alpha_helix_content = random.uniform(30, 60)
        beta_sheet_content = random.uniform(15, 35)
        loop_content = 100 - alpha_helix_content - beta_sheet_content
        
        # Stability prediction
        stability_score = (
            0.3 * (hydrophobicity / 100) +
            0.2 * (alpha_helix_content / 100) +
            0.2 * (beta_sheet_content / 100) +
            0.3 * random.uniform(0.6, 0.9)
        )
        
        return {
            'sequence_length': total_aa,
            'amino_acid_composition': {
                'nonpolar': round(aa_counts['nonpolar'] / total_aa * 100, 1),
                'polar': round(aa_counts['polar'] / total_aa * 100, 1),
                'positive': round(aa_counts['positive'] / total_aa * 100, 1),
                'negative': round(aa_counts['negative'] / total_aa * 100, 1)
            },
            'size_distribution': {
                'small': round(size_counts['small'] / total_aa * 100, 1),
                'medium': round(size_counts['medium'] / total_aa * 100, 1),
                'large': round(size_counts['large'] / total_aa * 100, 1)
            },
            'predicted_properties': {
                'hydrophobicity': round(hydrophobicity, 1),
                'charge_ratio': round(charge_ratio, 1),
                'stability_score': round(stability_score, 3)
            },
            'secondary_structure': {
                'alpha_helix': round(alpha_helix_content, 1),
                'beta_sheet': round(beta_sheet_content, 1),
                'loops': round(loop_content, 1)
            }
        }
    
    def generate_binding_site_info(self, sequence: str, target_disease: str) -> Dict:
        """Generate binding site information for the target disease"""
        
        # Select potential binding sites (simplified)
        binding_sites = []
        sequence_length = len(sequence)
        
        # Generate 2-4 binding sites
        num_sites = random.randint(2, 4)
        
        for i in range(num_sites):
            start_pos = random.randint(1, max(1, sequence_length - 10))
            end_pos = min(start_pos + random.randint(5, 12), sequence_length)
            
            site_sequence = sequence[start_pos-1:end_pos]
            
            # Binding affinity (simplified)
            affinity = random.uniform(0.1, 50.0)  # nM
            
            binding_sites.append({
                'site_id': f"BS{i+1}",
                'position': f"{start_pos}-{end_pos}",
                'sequence': site_sequence,
                'predicted_affinity': round(affinity, 2),
                'confidence': round(random.uniform(0.7, 0.95), 3)
            })
        
        return {
            'target_disease': target_disease,
            'binding_sites': binding_sites,
            'overall_binding_score': round(random.uniform(0.75, 0.95), 3)
        }

# Example usage and testing
if __name__ == "__main__":
    visualizer = MolecularVisualizer()
    
    # Generate a test protein
    protein_name = "COB-onc7a"
    sequence_length = 85
    sequence = visualizer.generate_protein_sequence(sequence_length, "therapeutic")
    
    print(f"Generated Protein: {protein_name}")
    print(f"Sequence ({len(sequence)} AA): {sequence}")
    
    # Generate structure analysis
    analysis = visualizer.generate_structure_analysis(sequence)
    print(f"\nStructure Analysis:")
    print(f"Hydrophobicity: {analysis['predicted_properties']['hydrophobicity']}%")
    print(f"Alpha helix content: {analysis['secondary_structure']['alpha_helix']}%")
    print(f"Stability score: {analysis['predicted_properties']['stability_score']}")
    
    # Generate binding site info
    binding_info = visualizer.generate_binding_site_info(sequence, "glioblastoma")
    print(f"\nBinding Sites for {binding_info['target_disease']}:")
    for site in binding_info['binding_sites']:
        print(f"  {site['site_id']}: {site['sequence']} (Affinity: {site['predicted_affinity']} nM)")
    
    # Generate PDB structure
    pdb_structure = visualizer.generate_pdb_structure(sequence, protein_name)
    print(f"\nPDB Structure generated ({len(pdb_structure.split())} lines)")

